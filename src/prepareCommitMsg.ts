/**
 * Prepare commit message.
 *
 * This module ties together logic from modules in the `generate` module. So it is best kept outside
 * that.
 *
 * The "message" is the full commit message. The "file change description" is the description
 * portion, which describes how the files changed.
 *
 * This module doesn't interact with the git CLI or the extension. It just deals with text.
 */
import { lookupDiffIndexAction } from "./generate/action";
import { getConventionType } from "./generate/convCommit";
import { namedFiles, oneChange } from "./generate/message";
import { parseDiffIndex } from "./git/parseOutput";
import { CONVENTIONAL_TYPE } from "./lib/constants";
import { equal } from "./lib/utils";

/**
 * Join two strings together with a space, or just one string if only one is set.
 *
 * Trimming on the outside is necessary, in case only one item is set.
 * Don't both trimming the items before joining them, as this project doesn't need that for where
 * this is used.
 */
export function _cleanJoin(first: string, second: string) {
  return [first, second].join(" ").trim();
}

/**
 * Separate a message into a Conventional Commit prefix, if any, and the description.
 *
 * Require a colon to exist to detect prefix. i.e. 'ci' will be considered a description, but 'ci:'
 * will be considered a prefix. This keeps the check simpler as we don't have to match against every
 * type and we don' have to check if we are part of a word e.g. 'circus'.
 */
export function _splitMsg(msg: string) {
  const [prefix, fileChangeDesc] = msg.includes(":")
    ? msg.split(":")
    : ["", msg];

  const [customPrefix, typePrefix] = prefix.includes(" ")
    ? prefix.split(" ", 2)
    : ["", prefix];

  return { customPrefix, typePrefix, fileChangeDesc: fileChangeDesc.trim() };
}

/**
 * Determine what the prefix should be for a file change, using Conventional Commit standard.
 */
function _prefixFromChanges(line: string) {
  const { x: actionChar, from: filePath } = parseDiffIndex(line);
  const action = lookupDiffIndexAction(actionChar);

  return getConventionType(action, filePath);
}

/**
 * Generate message for a single file change.
 */
export function _msgOne(line: string) {
  // TODO: Pass FileChanges to one and generatePrefix instead of string.
  // Don't unpack as {x, y, from, to}
  // const fileChanges = parseDiffIndex(line)
  const prefix = _prefixFromChanges(line),
    fileChangeDesc = oneChange(line);

  return { prefix, fileChangeDesc };
}

/**
 * Get single Conventional Commit type from multiple ones.
 *
 * If at least one item is build dependencies even if the others are different, then use that.
 * This covers the case where package.json may have non-package changes but you know it does
 * in this case because it changed with the lock file.
 */
function _collapse(conventions: CONVENTIONAL_TYPE[]) {
  if (equal(conventions)) {
    return conventions[0];
  }
  if (conventions.includes(CONVENTIONAL_TYPE.BUILD_DEPENDENCIES)) {
    return CONVENTIONAL_TYPE.BUILD_DEPENDENCIES;
  }

  return CONVENTIONAL_TYPE.UNKNOWN;
}

/**
 * Generate message for multiple file changes.
 *
 * This finds a common Conventional Commit prefix if one is appropriate and returns a message
 * listing all the names.
 *
 * This was added onto this extension later in development, while `_msgOne` was the core behavior
 * previously.
 */
export function _msgMulti(lines: string[]) {
  const conventions = lines.map(_prefixFromChanges);
  const convention = _collapse(conventions);

  return { prefix: convention, fileChangeDesc: namedFiles(lines) };
}

/**
 * Generate message from changes to one or more files.
 *
 * Return conventional commit prefix and a description of changed paths.
 */
export function _msgFromChanges(diffIndexLines: string[]) {
  if (diffIndexLines.length === 1) {
    const line = diffIndexLines[0];
    return _msgOne(line);
  }

  return _msgMulti(diffIndexLines);
}

/**
 * Output a readable conventional commit message.
 */
export function _formatMsg(prefix: CONVENTIONAL_TYPE, fileChangeDesc: string) {
  if (prefix === CONVENTIONAL_TYPE.UNKNOWN) {
    return fileChangeDesc;
  }
  return `${prefix}: ${fileChangeDesc}`;
}

/**
 * Generate a new commit message and format it as a string.
 */
export function _newMsg(lines: string[]) {
  const { prefix, fileChangeDesc } = _msgFromChanges(lines);

  return _formatMsg(prefix, fileChangeDesc);
}

/**
 * Format commit message using old and new messages.
 *
 * The point is to always use the new message and prefix, but respect the old message. If there is
 * no new prefix type set, use the old one, and if that is not set then just a simple message will
 * do.
 *
 * @param prefix The Conventional Commit prefix to use, as generated by the extension based on
 * changed files.
 * @param fileChangeDesc A description of changes, also generated.
 * @param oldMsg What exists in the commit message box when the extension is run, whether typed or
 * generated previously.
 */
export function _combineOldAndNew(
  prefix: CONVENTIONAL_TYPE,
  fileChangeDesc: string,
  oldMsg?: string
) {
  if (!oldMsg) {
    return _formatMsg(prefix, fileChangeDesc);
  }

  const {
    customPrefix: oldCustomPrefix,
    typePrefix: oldTypePrefix,
    fileChangeDesc: oldFileChangeDesc,
  } = _splitMsg(oldMsg);

  const fileChangeDescResult = _cleanJoin(oldFileChangeDesc, fileChangeDesc);

  if (prefix !== CONVENTIONAL_TYPE.UNKNOWN) {
    return `${_cleanJoin(oldCustomPrefix, prefix)}: ${fileChangeDescResult}`;
  }

  if (oldTypePrefix) {
    return `${_cleanJoin(
      oldCustomPrefix,
      oldTypePrefix
    )}: ${fileChangeDescResult}`;
  }

  return fileChangeDescResult;
}

/**
 * Generate commit message using existing message and new generated message.
 *
 * High-level function to process file changes and an old message to generate replacement commit
 * message. Old message must be given, but it can be an empty string.
 */
function generateMsgWithOld(fileChanges: string[], oldMsg: string) {
  if (oldMsg === "") {
    throw new Error(
      "Either `oldMsg` must not be empty, or use `generateNewMsg` instead."
    );
  }
  const { prefix, fileChangeDesc } = _msgFromChanges(fileChanges);

  return _combineOldAndNew(prefix, fileChangeDesc, oldMsg);
}

/**
 * Generate commit message.
 *
 * This is a public wrapper function to allow an existing message to be set or not.
 *
 * Old message could be the current commit message value in the UI box (which might be a commit
 * message template that VS Code has filled in), or a commit message template read from a file in
 * the case of a hook flow without VS Code.
 */
export function generateMsg(fileChanges: string[], oldMsg?: string): string {
  if (!oldMsg) {
    return _newMsg(fileChanges);
  } else {
    return generateMsgWithOld(fileChanges, oldMsg);
  }
}
